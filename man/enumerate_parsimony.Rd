% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parsimonyNumber.R
\name{enumerate_parsimony}
\alias{enumerate_parsimony}
\title{Enumerate all the possible regime allocations, given a culstering 
of the tips.}
\usage{
enumerate_parsimony(phylo, clusters = rep(1, length(phylo$tip.label)))
}
\arguments{
\item{phylo}{Input tree.}

\item{clusters}{a vector representing the group of each tip.}
}
\value{
an S3 object of class "\code{enumerate_parsimony}", with:
\describe{
\item{nbrReconstructions}{an object of class "\code{parsimonyCost}", result
of function \code{\link{parsimonyCost}}.}
\item{allocations}{a list of size nNode + ntaxa. Each entry i of the list
represents the solutions for the subtree starting at node i. It is a list with
nclus entries, each entry being a matrix. A line of the kth matrix for the
ith node is one possible allocation of the shifts, starting with regime k
for node i.}
\item{phylo}{the entry phylogenetic tree}
}
}
\description{
\code{enumerate_parsimony} enumerate all the equivalent allocation of the 
regimes in the tree, a clustering of the tips being given. The number of such
equivalent regimes is given by \code{parsimonyNumber} (which is faster).
}
\details{
This functin does a recursion up the tree, using functions 
\code{init.enumerate_parsimony} for the initialization at the tips, 
\code{updateUp_list} for the effective recursion on the tree,
and \code{update.enumerate_parsimony} for the actualisation of the parameters.
The function \code{extract_enumerate_parsimony} furnishes the result in a nice
form of a matrix (for any subtree).
}
\examples{
tree <- read.tree(text="(((0,1),2),2);")
plot(tree); nodelabels()
clusters <- c(0, 1, 2, 2)
sols <- enumerate_parsimony(tree, clusters)

## Extract the parsimonious solutions from the root
extract(sols) # each line is a solution, with states of each node
## Extract the number of solutions from the root
extract(sols, what = "number")
# same result, more efficient:
extract(parsimonyNumber(tree, clusters))
## Extract the cost of the solutions from the root
extract(sols, what = "cost")
# same, but less efficient than:
extract(parsimonyCost(tree, clusters))
## Extract for the sub-tree below node 7
extract(sols, 7)
# NAs: non-existing nodes in the sub-tree
plot(sols)

}

