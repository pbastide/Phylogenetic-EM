#############################################
## Exploitation several K
#############################################

##############
## Parameters and functions
##############

require(doParallel)
require(foreach)
require(ape)
#require(glmnet) # For Lasso initialization
require(quadrupen) # For Lasso initialization
require(robustbase) # For robust fitting of alpha
library(TreeSim) # For simulation of the tree
require(ggplot2) # Plot
library(scales) # plot
library(reshape2) # Plot
library(grid) # Plot
library(plyr)

## Source functions
source("R/simulate.R")
source("R/estimateEM.R")
source("R/init_EM.R")
source("R/E_step.R")
source("R/M_step.R")
source("R/shutoff.R")
source("R/generic_functions.R")
source("R/shifts_manipulations.R")
source("R/plot_functions.R")
source("R/parsimonyNumber.R")
source("R/partitionsNumber.R")
source("R/model_selection.R")

saveresultfile = "../Results/Simulations_Several_K/several_K_estimations"
datestamp_day <- "2015-03-06"
inference.index <- 0

load(paste0(saveresultfile, "_alpha_known-", datestamp_day, "_", inference.index, ".RData"))

simestimations_alpha_known <- simestimations_alpha_known_0
rm(simestimations_alpha_known_0)

#########################################################
## Model Selection
#########################################################

## Compute penalty and criteria for each set of parameters
penalty <- function(K_try, complexity, ntaxa){
  return(1/2 * penalty_BaraudGiraudHuet_likelihood(K_try, 
                                                   complexity, 
                                                   ntaxa, 
                                                   C = 1.1))
} 

criteria <- function(ll, pen){
  return(-ll + pen)
}

selected_K <- function(crit_ll, K_try){
  K_try[which.min(crit_ll)]
}

add_crit_and_pen <- function(z){
  z$pen_ll <- penalty(z$K_try,
                      z$complexity,
                      z$ntaxa)
  z$crit_ll <- criteria(z$log_likelihood,
                        z$pen_ll)
  z$K_select <- z$K_try[which.min(z$crit_ll)]
  return(z)
}

## Find K_select and add it to the list of results
add_K_select_to_list <- function(simest){
  simest$results_summary <- ddply(simest$results_summary,
                                  .(alpha, gamma, K, n, ntaxa, grp),
                                  add_crit_and_pen)
  simest$K_select <- unique(simest$results_summary$K_select)
  return(simest)
}

simestimations_alpha_known <- lapply(simestimations_alpha_known, add_K_select_to_list)

######################
## Extract inferences with K_true or K_select
######################

## Extract the results where K_try = K_e (K_true or something else)
extract_result <- function(simest, Ke){
  K_try <- 0:(length(simest$params_estim) - 1)
  if (Ke >= length(simest$params_estim)) return(NULL)
  fun <- function(l){
    if (Ke %in% names(l)) return(l[[paste(Ke)]])
    return(l)
  }
  res <- lapply(simest, fun)
  res$results_summary  <-  subset(simest$results_summary, K_try == Ke)
  return(res)
}

## Extract K_true
extract_result_K_true <- function(simest){
  K_true <- simest$K
  return(extract_result(simest, K_true))
}

simestimations_alpha_known_K_true <- lapply(simestimations_alpha_known, extract_result_K_true)

## Extract K_select
extract_result_K_select <- function(simest){
  K_select <- simest$K_select
  return(extract_result(simest, K_select))
}

simestimations_alpha_known_K_select <- lapply(simestimations_alpha_known, extract_result_K_select)

###########################################
## Scores involving lists
## (Compute complex score and add them to result summary for each element of the list)
###########################################
sensitivity <- function(tr.edges, est.edges) { # Sensibilité
  if (is.null(tr.edges) ) return(NA) # If no true shift at all, any shift found is misplaced
  if (is.null(est.edges)) return(0) # If no estimated shift, TP = 0
  return(sum(est.edges %in% tr.edges)/length(tr.edges))
}

specificity <- function(tr.edges, est.edges, nedges) { # spécificité
  edges <- 1:nedges
  if (is.null(est.edges)) est.edges <- nedges + 1
  if (is.null(tr.edges)) tr.edges <- nedges + 1
  return(sum(edges[-est.edges] %in% edges[-tr.edges])/length(edges[-tr.edges]))
}

precision <- function(tr.edges, est.edges) { # Precision
  if (is.null(tr.edges) ) return(NA) # If no true shift at all, any shift found is misplaced
  if (is.null(est.edges)) return(0) # If no estimated shift, TP = 0
  return(sum(est.edges %in% tr.edges)/length(est.edges))
}

match.partitions <- function(tr, est, nta) {
  tree <- trees[[paste0(nta)]]
  part.list <- subtree.list[[paste0(nta)]]
  ## computes ARI between partitions induced by edges in tr$edges and est$edges
  #   if (is.null(est$edges)){
  #     return(-1) # If lasso initialization failed
  #   } else {
  require(mclust)
  part1 <- clusters_from_shifts_ism(tree, tr$edges, part.list)
  part2 <- clusters_from_shifts_ism(tree, est$edges, part.list)
  return(adjustedRandIndex(part1, part2))        
  #   }
}


compute_list_scores_element <- function(simest){
  if (is.null(simest)){ # || !simest$results_summary$CV_estim){
    #     return(data.frame(mean.edge.quality = NA, edge.recovery = NA,
    #                       edge.init.recovery = NA, adjrandind = NA, adjrandind.init = NA))
    return(NULL)
  } else {
    df <- data.frame(
      mean.edge.quality = mean(simest$edge.quality),
      sensitivity = sensitivity(simest$shifts$edges,
                                simest$params_estim$shifts$edges),
      sensitivity.init = sensitivity(simest$shifts$edges,
                                     simest$params_init_estim$shifts$edges),
      specificity = specificity(simest$shifts$edges,
                                simest$params_estim$shifts$edges,
                                length(simest$Z_data) + length(simest$Y_data) - 1),
      specificity.init = specificity(simest$shifts$edges,
                                     simest$params_init_estim$shifts$edges,
                                     length(simest$Z_data) + length(simest$Y_data) - 1),
      precision = precision(simest$shifts$edges,
                            simest$params_estim$shifts$edges),
      precision.init = precision(simest$shifts$edges,
                                 simest$params_init_estim$shifts$edges),
      adjrandind = match.partitions(simest$shifts, 
                                    simest$params_estim$shifts,
                                    simest$ntaxa),
      adjrandind.init = match.partitions(simest$shifts, 
                                         simest$params_init_estim$shifts,
                                         simest$ntaxa)
    )
    simest$results_summary <- cbind(simest$results_summary, df)
    return(simest)
  }
}

simestimations_alpha_known_K_true <- lapply(simestimations_alpha_known_K_true, compute_list_scores_element)
simestimations_alpha_known_K_select <- lapply(simestimations_alpha_known_K_select, compute_list_scores_element)

######################
## Format the data
######################

extract_data_frame <- function(simests){
  dd <- do.call(rbind, simests)
  results_summary <- as.data.frame(do.call(rbind, dd[,"results_summary"]))
  return(results_summary)
}

results_summary <- extract_data_frame(simestimations_alpha_known)
results_summary_K_true <- extract_data_frame(simestimations_alpha_known_K_true)
results_summary_K_select <- extract_data_frame(simestimations_alpha_known_K_select)

results_summary_K_true$K_type <- "K_true"
results_summary_K_select$K_type <- "K_select"
results_summary_K_select_true <- rbind(results_summary_K_true, 
                                      results_summary_K_select)

######################################################################
## Sumarizing Function
######################################################################
## Simple Scores
RMSE <- function(y, true.value) {
  return(sqrt(mean((y - true.value)^2)))
}

compute_scores <- function(res_sum){
  # Combinations of "true" parameters (no n)
  # Aggregation of parameter estimates conditonal upon convergence of EM procedure
  return(ddply(subset(res_sum, CV_estim == 1),
               .(alpha, gamma, K, ntaxa, grp),
               summarize,
               ## Simple Scores
               alpha.mean = mean(alpha_estim),
               alpha.sd = sd(alpha_estim),
               alpha.RMSE = RMSE(alpha_estim, unique(alpha)),
               alpha.init.RMSE = RMSE(alpha_estim_init, unique(alpha)),
               gamma.mean = mean(gamma_estim),
               gamma.sd = sd(gamma_estim),
               gamma.RMSE = RMSE(gamma_estim, unique(gamma)),
               gamma.init.RMSE = RMSE(gamma_estim_init, unique(gamma)),
               beta_0.mean = mean(beta_0_estim),
               beta_0.sd = sd(beta_0_estim),
               beta_0.RMSE = RMSE(beta_0_estim, beta_0),
               beta_0.init.RMSE = RMSE(beta_0_estim_init, beta_0),
               log_likelihood.mean = mean(log_likelihood),
               log_likelihood.mean.init = mean(log_likelihood_init),
               mean_number_new_shifts.mean = mean(mean_number_new_shifts),
               number_equivalent_solutions.mean = mean(number_equivalent_solutions),
               difficulty.mean = mean(difficulty),
               EM_steps.mean = mean(EM_steps, na.rm = TRUE),
               K.match = mean(K == K_try),
               K.match.leq = mean(K >= K_try),
               ## List Scores
               mean.edge.quality.mean = mean(mean.edge.quality),
               sensitivity.mean = mean(sensitivity),
               sensitivity.init.mean = mean(sensitivity.init),
               specificity.mean = mean(specificity),
               specificity.init.mean = mean(specificity.init),
               precision.mean = mean(precision),
               precision.init.mean = mean(precision.init),
               mean.adjrandind = mean(adjrandind),
               mean.adjrandind.init = mean(adjrandind.init)
  ))
}

summary_scores_K_true <- compute_scores(results_summary_K_true)
summary_scores_K_select <- compute_scores(results_summary_K_select_true)

summary_scores_K_true$K_type <- "K_true"
summary_scores_K_select$K_type <- "K_select"
summary_scores_K_select_true <- rbind(summary_scores_K_true, 
                                      summary_scores_K_select)
rm(summary_scores_K_true, summary_scores_K_select)

save.image(paste0(saveresultfile, "_aranged", "_alpha_known-", datestamp_day, "_", inference.index, ".RData"))

#################################################################
## Plots
#################################################################
load(paste0(saveresultfile, "_aranged", "_alpha_known-", datestamp_day, "_", inference.index, ".RData"))

## Utility functions
gtable_filter <- function (x, pattern, fixed = FALSE, trim = TRUE, complementary = FALSE) 
{
  matches <- grepl(pattern, x$layout$name, fixed = fixed)
  if (complementary) matches <- !matches
  x$layout <- x$layout[matches, , drop = FALSE]
  x$grobs <- x$grobs[matches]
  if (trim) 
    x <- gtable_trim(x)
  x
}

g_table_replace_xlab_strips <- function(g){
  xlab <- gtable_filter(g, "xlab", trim = FALSE, complementary = FALSE)
  g <- gtable_filter(g, "xlab", trim = FALSE, complementary = TRUE)
  matches <- grepl("strip-top", g$layout$name)
  g$layout[matches, "t"] <- xlab$layout[1,"t"]
  g$layout[matches, "b"] <- xlab$layout[1,"b"]
  return(g)
}

my.labeller <- function(variable, value) {
  value <- paste(variable, "==", as.character(value))
  value <- lapply(value, function(x) parse(text = x))
  return(value)
}

## Format data for plots
format_plot <- function(df){
  # Save true values
  df$alpha.true <- df$alpha
  df$gamma.true <- df$gamma
  df$K.true <- df$K
  
  # Transformations and names
  df[["ln(2)/alpha"]] <- log(2)/df$alpha
  df[["sigma^2 == 2*alpha*gamma^2"]] <- 2*df$alpha*df$gamma
  
  # Melt
  df_plot <- melt(df, 
                  measure.vars = c("ln(2)/alpha", "sigma^2 == 2*alpha*gamma^2", "K"),
                  value.name = "parameter.value")
  
  # Supress lines where group != variable
  grp_var <- c(alpha_var = "ln(2)/alpha", 
               gamma_var = "sigma^2 == 2*alpha*gamma^2", 
               K_var = "K")
  fun <- function(z){
    if (z["grp"] == "base") return(TRUE)
    return(unname(grp_var[z["grp"]] == z["variable"]))
  }
  masque <- apply(df_plot, 1, fun)
  df_plot <- df_plot[masque,]
  df_plot$ntaxa <- as.factor(df_plot$ntaxa)
  df_plot$parameter.value <- round(df_plot$parameter.value, 2)
  df_plot$parameter.value <- as.factor(df_plot$parameter.value)
  return(df_plot)
}

summary_scores_K_select_true_plot <- format_plot(summary_scores_K_select_true)
results_summary_K_select_true_plot <- format_plot(results_summary_K_select_true)

## Plot functions
plot_results_score <- function(score, score_name){
  p <- ggplot(summary_scores_K_select_true_plot,
              aes_string(x = "parameter.value",
                  y = score,
                  linetype = "K_type",
                  color = "ntaxa"))
  p <- p + aes(group = interaction(ntaxa, K_type))
  p <- p + facet_grid(. ~ variable, labeller = label_parsed, scales = "free")
  p <- p + scale_linetype(name = "Estimation")
  p <- p + geom_line()
  p <- p + scale_colour_discrete(name = "ntaxa")
  p <- p + labs(x = "",
                y = score_name)
  #p <- p + scale_x_continuous(trans = log_trans(10))
  p <- p + theme_bw()
  p <- p + theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 1))
  p <- p + theme(axis.text = element_text(size = 12),
                 strip.text = element_text(size = 12),
                 strip.background = element_blank()
                 ##legend.position = c(0, 1),
                 ##legend.justification = c(0, 1)
  )
  g <- ggplotGrob(p)
  g <- g_table_replace_xlab_strips(g)
  grid.newpage()
  grid.draw(g)
}

plot_results_score_smooth <- function(score, score_name){
  replace_name <- function(i){
    i <- as.integer(as.character(i))
    i <- formatC(i, width = 3, format = "d", flag = "0")
    i <- paste0("ntaxa == ", i)
    return(i)
  }
  data <- results_summary_K_select_true_plot
  data$ntaxa <- sapply(data$ntaxa, replace_name)
  data$ntaxa <- as.factor(data$ntaxa)
  p <- ggplot(data,
              aes_string(x = "parameter.value",
                         y = score,
                         color = "K_type"))
#  p <- p + aes(group = interaction(ntaxa, K_type))
  p <- p + facet_grid(ntaxa ~ variable, labeller = label_parsed, scales = "free", shrink = TRUE)
#   p <- p + scale_linetype(name = "Estimation")
  p <- p + geom_smooth(aes(group = K_type), method = "loess", se = FALSE)
  p <- p + geom_boxplot()
  p <- p + scale_colour_discrete(name = "Estimation")
  p <- p + labs(x = "",
                y = score_name)
  #p <- p + scale_x_continuous(trans = log_trans(10))
  p <- p + theme_bw()
  p <- p + theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 1))
  p <- p + theme(axis.text = element_text(size = 12),
                 strip.text = element_text(size = 12),
                 strip.background = element_blank()
                 ##legend.position = c(0, 1),
                 ##legend.justification = c(0, 1)
  )
  g <- ggplotGrob(p)
  g <- g_table_replace_xlab_strips(g)
  grid.newpage()
  grid.draw(g)
}

## Gamma RMSE
plot_results_score("gamma.RMSE/gamma.true", 
                   expression(paste("RMSE(", gamma^2, ")/", gamma^2)))
plot_results_score_smooth("gamma_estim", 
                          expression(paste("Estimated ", gamma^2)))

## beta_0 RMSE
plot_results_score("beta_0.RMSE", 
                   expression(paste("RMSE(", beta[0], ")")))
plot_results_score_smooth("beta_0_estim", 
                          expression(paste("Estimated ", beta[0])))

## log_likelihood
plot_results_score("log_likelihood.mean", "Log Likelihood")
plot_results_score_smooth("log_likelihood", "Log Likelihood")

## ARI
plot_results_score("mean.adjrandind", "ARI")
plot_results_score_smooth("adjrandind", "ARI")

## K match
plot_results_score("K.match", "Percent Exact Match")

## Sensibilité, spécificité, précision
plot_results_score_smooth("sensitivity", "Sensibility")
plot_results_score_smooth("1 - specificity", "False Positive Rate")
plot_results_score_smooth("1 - precision", "False Discovery Rate")

## K_true vs K_select
nbr_inferences_K <- function(df){
  len <- unique(floor(sqrt(nta)))
  res <- vector(length = len + 1)
  names(res) <- 0:len
  for (K_e in 0:len){
    res[K_e + 1] <- sum(df$K_select == K_e) / length(df$K_select)
  }
  names(res) <- 0:len
  return(res)
}

incidences_K_select <- ddply(results_summary,
                             .(K, ntaxa),
                             nbr_inferences_K)

incidences_K_select <- melt(incidences_K_select,
                            id.vars = c("K", "ntaxa"), 
                            variable.name = "K_select",
                            value.name = "frequence_observed")

incidences_K_select$K_select <- as.numeric(levels(incidences_K_select$K_select))[incidences_K_select$K_select]

incidences_K_select <- merge(results_summary, incidences_K_select)

p <- ggplot(incidences_K_select, aes(x = K, y = K_select, size = frequence_observed))
p <- p + facet_grid(. ~ ntaxa, labeller = my.labeller)
p <- p + geom_abline(intercept = 0, slope=1)
p <- p + geom_hline(aes(yintercept = floor(sqrt(ntaxa))))
p <- p + geom_smooth(method = "lm", se = FALSE, show_guide=FALSE)
p <- p + geom_point()
p <- p + scale_size(name = "Frequence Estimated")
#                           breaks = c("FALSE", "TRUE"),
#                           labels = c("Estimated", "Known"))
p <- p + theme_bw()
p <- p + theme(axis.text = element_text(size = 12),
               strip.text = element_text(size = 12)
               ##legend.position = c(0, 1),
               ##legend.justification = c(0, 1)
)
p

## Faire un box plot
p <- ggplot(results_summary, aes(x = as.factor(K), y = K_select))
p <- p + facet_grid(. ~ ntaxa, labeller = my.labeller)
p <- p + geom_boxplot()
p <- p + geom_abline(intercept = 0, slope=1)
p <- p + geom_hline(aes(yintercept = floor(sqrt(ntaxa))))
p <- p + geom_smooth(aes(group = 1), method = "lm", se = FALSE, show_guide=FALSE)
p <- p + scale_size(name = "Frequence Estimated")
#                           breaks = c("FALSE", "TRUE"),
#                           labels = c("Estimated", "Known"))
p <- p + labs(x = "True K",
              y = "Selected K")
p <- p + coord_cartesian(ylim = c(-0.5, 16.5))
p <- p + theme_bw()
p <- p + theme(axis.text = element_text(size = 12),
               strip.text = element_text(size = 12)
               ##legend.position = c(0, 1),
               ##legend.justification = c(0, 1)
)
p
