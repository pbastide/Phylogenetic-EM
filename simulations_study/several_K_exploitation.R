#############################################
## Exploitation several K
#############################################

##############
## Parameters and functions
##############

require(doParallel)
require(foreach)
require(ape)
#require(glmnet) # For Lasso initialization
require(quadrupen) # For Lasso initialization
require(robustbase) # For robust fitting of alpha
library(TreeSim) # For simulation of the tree
require(ggplot2) # Plot
library(scales) # plot
library(reshape2) # Plot
library(grid) # Plot
library(plyr)

## Source functions
source("R/simulate.R")
source("R/estimateEM.R")
source("R/init_EM.R")
source("R/E_step.R")
source("R/M_step.R")
source("R/shutoff.R")
source("R/generic_functions.R")
source("R/shifts_manipulations.R")
source("R/plot_functions.R")
source("R/parsimonyNumber.R")
source("R/partitionsNumber.R")
source("R/model_selection.R")

saveresultfile = "../Results/Simulations_Several_K/several_K_estimations"
datestamp_day <- "2015-03-06"
inference.index <- 0

load(paste0(saveresultfile, "_alpha_known-", datestamp_day, "_", inference.index, ".RData"))

simestimations_alpha_known <- simestimations_alpha_known_0
rm(simestimations_alpha_known_0)

#########################################################
## Model Selection
#########################################################

## Compute penalty and criteria for each set of parameters
penalty <- function(K_try, complexity, ntaxa){
  return(1/2 * penalty_BaraudGiraudHuet_likelihood(K_try, 
                                                   complexity, 
                                                   ntaxa, 
                                                   C = 1.1))
} 

criteria <- function(ll, pen){
  return(-ll + pen)
}

selected_K <- function(crit_ll, K_try){
  K_try[which.min(crit_ll)]
}

add_crit_and_pen <- function(z){
  z$pen_ll <- penalty(z$K_try,
                      z$complexity,
                      z$ntaxa)
  z$crit_ll <- criteria(z$log_likelihood,
                        z$pen_ll)
  z$K_select <- z$K_try[which.min(z$crit_ll)]
  return(z)
}

## Find K_select and add it to the list of results
add_K_select_to_list <- function(simest){
  simest$results_summary <- ddply(simest$results_summary,
                                  .(alpha, gamma, K, n, ntaxa, grp),
                                  add_crit_and_pen)
  simest$K_select <- unique(simest$results_summary$K_select)
  return(simest)
}

simestimations_alpha_known <- lapply(simestimations_alpha_known, add_K_select_to_list)

######################
## Extract inferences with K_true or K_select
######################

## Extract the results where K_try = K_e (K_true or something else)
extract_result <- function(simest, Ke){
  K_try <- 0:(length(simest$params_estim) - 1)
  if (Ke >= length(simest$params_estim)) return(NULL)
  fun <- function(l){
    if (Ke %in% names(l)) return(l[[paste(Ke)]])
    return(l)
  }
  res <- lapply(simest, fun)
  res$results_summary  <-  subset(simest$results_summary, K_try == Ke)
  return(res)
}

## Extract K_true
extract_result_K_true <- function(simest){
  K_true <- simest$K
  return(extract_result(simest, K_true))
}

simestimations_alpha_known_K_true <- lapply(simestimations_alpha_known, extract_result_K_true)

## Extract K_select
extract_result_K_select <- function(simest){
  K_select <- simest$K_select
  return(extract_result(simest, K_select))
}

simestimations_alpha_known_K_select <- lapply(simestimations_alpha_known, extract_result_K_select)

###########################################
## Scores involving lists
## (Compute complex score and add them to result summary for each element of the list)
###########################################
match.edges.shift <- function(tr.edges, est.edges) { # Sensibilité
  if (is.null(tr.edges) ) return(NA) # If no true shift at all, any shift found is misplaced
  if (is.null(est.edges)) return(0) # If no estimated shift, TP = 0
  return(sum(est.edges %in% tr.edges)/length(tr.edges))
}

match.edges.no_shift <- function(tr.edges, est.edges, nedges) { # spécificité
  edges <- 1:nedges
  if (is.null(est.edges)) est.edges <- nedges + 1
  if (is.null(tr.edges)) tr.edges <- nedges + 1
  return(sum(edges[-est.edges] %in% edges[-tr.edges])/length(edges[-tr.edges]))
}

match.partitions <- function(tr, est, nta) {
  tree <- trees[[paste0(nta)]]
  part.list <- subtree.list[[paste0(nta)]]
  ## computes ARI between partitions induced by edges in tr$edges and est$edges
  #   if (is.null(est$edges)){
  #     return(-1) # If lasso initialization failed
  #   } else {
  require(mclust)
  part1 <- clusters_from_shifts_ism(tree, tr$edges, part.list)
  part2 <- clusters_from_shifts_ism(tree, est$edges, part.list)
  return(adjustedRandIndex(part1, part2))        
  #   }
}


compute_list_scores_element <- function(simest){
  if (is.null(simest)){ # || !simest$results_summary$CV_estim){
    #     return(data.frame(mean.edge.quality = NA, edge.recovery = NA,
    #                       edge.init.recovery = NA, adjrandind = NA, adjrandind.init = NA))
    return(NULL)
  } else {
    df <- data.frame(
      mean.edge.quality = mean(simest$edge.quality),
      edge.recovery = match.edges.shift(simest$shifts$edges,
                                        simest$params_estim$shifts$edges),
      edge.init.recovery = match.edges.shift(simest$shifts$edges,
                                             simest$params_init_estim$shifts$edges),
      no_shift.edge.recovery = match.edges.no_shift(simest$shifts$edges,
                                                    simest$params_estim$shifts$edges,
                                                    length(simest$Z_data) + length(simest$Y_data) - 1),
      no_shift.edge.init.recovery = match.edges.no_shift(simest$shifts$edges,
                                                         simest$params_init_estim$shifts$edges,
                                                         length(simest$Z_data) + length(simest$Y_data) - 1),
      adjrandind = match.partitions(simest$shifts, 
                                    simest$params_estim$shifts,
                                    simest$ntaxa),
      adjrandind.init = match.partitions(simest$shifts, 
                                         simest$params_init_estim$shifts,
                                         simest$ntaxa)
    )
    simest$results_summary <- cbind(simest$results_summary, df)
    return(simest)
  }
}

simestimations_alpha_known_K_true <- lapply(simestimations_alpha_known_K_true, compute_list_scores_element)
simestimations_alpha_known_K_select <- lapply(simestimations_alpha_known_K_select, compute_list_scores_element)

######################
## Format the data
######################

extract_data_frame <- function(simests){
  dd <- do.call(rbind, simests)
  results_summary <- as.data.frame(do.call(rbind, dd[,"results_summary"]))
  return(results_summary)
}

results_summary <- extract_data_frame(simestimations_alpha_known)
results_summary_K_true <- extract_data_frame(simestimations_alpha_known_K_true)
results_summary_K_select <- extract_data_frame(simestimations_alpha_known_K_select)

results_summary_K_true$K_type <- "K_true"
results_summary_K_select$K_type <- "K_select"
results_summary_K_select_true <- rbind(results_summary_K_true, 
                                      results_summary_K_select)

######################################################################
## Sumarizing Function
######################################################################
## Simple Scores
RMSE <- function(y, true.value) {
  return(sqrt(mean((y - true.value)^2)))
}

compute_scores <- function(res_sum){
  # Combinations of "true" parameters (no n)
  # Aggregation of parameter estimates conditonal upon convergence of EM procedure
  return(ddply(subset(res_sum, CV_estim == 1),
               .(alpha, gamma, K, ntaxa, grp),
               summarize,
               ## Simple Scores
               alpha.mean = mean(alpha_estim),
               alpha.sd = sd(alpha_estim),
               alpha.RMSE = RMSE(alpha_estim, unique(alpha)),
               alpha.init.RMSE = RMSE(alpha_estim_init, unique(alpha)),
               gamma.mean = mean(gamma_estim),
               gamma.sd = sd(gamma_estim),
               gamma.RMSE = RMSE(gamma_estim, unique(gamma)),
               gamma.init.RMSE = RMSE(gamma_estim_init, unique(gamma)),
               beta_0.mean = mean(beta_0_estim),
               beta_0.sd = sd(beta_0_estim),
               beta_0.RMSE = RMSE(beta_0_estim, beta_0),
               beta_0.init.RMSE = RMSE(beta_0_estim_init, beta_0),
               log_likelihood.mean = mean(log_likelihood),
               log_likelihood.mean.init = mean(log_likelihood_init),
               mean.mean_number_new_shifts = mean(mean_number_new_shifts),
               mean.number_equivalent_solutions = mean(number_equivalent_solutions),
               mean.difficulty = mean(difficulty),
               mean.EM_steps = mean(EM_steps, na.rm = TRUE),
               K.match = mean(K == K_try),
               K.match.leq = mean(K >= K_try),
               ## List Scores
               mean.mean.edge.quality = mean(mean.edge.quality),
               mean.edge.recovery = mean(edge.recovery),
               mean.edge.init.recovery = mean(edge.init.recovery),
               mean.no_shift.edge.recovery = mean(no_shift.edge.recovery),
               mean.no_shift.edge.init.recovery = mean(no_shift.edge.recovery),
               mean.adjrandind = mean(adjrandind),
               mean.adjrandind.init = mean(adjrandind.init)
  ))
}

summary_scores_K_true <- compute_scores(results_summary_K_true)
summary_scores_K_select <- compute_scores(results_summary_K_select_true)

summary_scores_K_true$K_type <- "K_true"
summary_scores_K_select$K_type <- "K_select"
summary_scores_K_select_true <- rbind(summary_scores_K_true, 
                                      summary_scores_K_select)
rm(summary_scores_K_true, summary_scores_K_select)

save.image(paste0(saveresultfile, "_aranged", "_alpha_known-", datestamp_day, "_", inference.index, ".RData"))

#################################################################
## Plots
#################################################################
load(paste0(saveresultfile, "_aranged", "_alpha_known-", datestamp_day, "_", inference.index, ".RData"))

## Utility functions
gtable_filter <- function (x, pattern, fixed = FALSE, trim = TRUE, complementary = FALSE) 
{
  matches <- grepl(pattern, x$layout$name, fixed = fixed)
  if (complementary) matches <- !matches
  x$layout <- x$layout[matches, , drop = FALSE]
  x$grobs <- x$grobs[matches]
  if (trim) 
    x <- gtable_trim(x)
  x
}

g_table_replace_xlab_strips <- function(g){
  xlab <- gtable_filter(g, "xlab", trim = FALSE, complementary = FALSE)
  g <- gtable_filter(g, "xlab", trim = FALSE, complementary = TRUE)
  matches <- grepl("strip-top", g$layout$name)
  g$layout[matches, "t"] <- xlab$layout[1,"t"]
  g$layout[matches, "b"] <- xlab$layout[1,"b"]
  return(g)
}

my.labeller <- function(variable, value) {
  value <- paste(variable, "==", as.character(value))
  value <- lapply(value, function(x) parse(text = x))
  return(value)
}

## Format data for plots
# Expand data frame
summary_scores_K_select_true$alpha.true <- summary_scores_K_select_true$alpha
summary_scores_K_select_true$gamma.true <- summary_scores_K_select_true$gamma
summary_scores_K_select_true$K.true <- summary_scores_K_select_true$K

summary_scores_K_select_true[["ln(2)/alpha"]] <- log(2)/summary_scores_K_select_true$alpha
summary_scores_K_select_true[["gamma^2"]] <- summary_scores_K_select_true$gamma

summary_scores_K_select_true_plot <- melt(summary_scores_K_select_true, 
                                          measure.vars = c("ln(2)/alpha", "gamma^2", "K"),
                                          value.name = "parameter.value")

# Supress lines where group != variable
grp_var <- c(alpha_var = "ln(2)/alpha", 
             gamma_var = "gamma^2", 
             K_var = "K")

fun <- function(z){
  if (z["grp"] == "base") return(TRUE)
  return(unname(grp_var[z["grp"]] == z["variable"]))
}
masque <- apply(summary_scores_K_select_true_plot, 1, fun)
summary_scores_K_select_true_plot <- summary_scores_K_select_true_plot[masque,]
rm(fun, masque)
summary_scores_K_select_true_plot$ntaxa <- as.factor(summary_scores_K_select_true_plot$ntaxa)

## Plot function
plot_results_score <- function(score, score_name){
  p <- ggplot(summary_scores_K_select_true_plot,
              aes_string(x = "parameter.value",
                  y = score,
                  linetype = "ntaxa",
                  color = "K_type"))
  p <- p + facet_grid(. ~ variable, labeller = label_parsed, scales = "free")
  p <- p + scale_linetype(name = "ntaxa")
  p <- p + geom_line()
  p <- p + scale_colour_discrete(name = "Estimation")
  p <- p + labs(x = "",
                y = score_name)
  #p <- p + scale_x_continuous(trans = log_trans(10))
  p <- p + theme_bw()
  p <- p + theme(axis.text = element_text(size = 12),
                 strip.text = element_text(size = 12),
                 strip.background = element_blank()
                 ##legend.position = c(0, 1),
                 ##legend.justification = c(0, 1)
  )
  g <- ggplotGrob(p)
  g <- g_table_replace_xlab_strips(g)
  grid.newpage()
  grid.draw(g)
}

## Gamma RMSE
plot_results_score("gamma.RMSE/gamma.true", 
                   expression(paste("RMSE(", gamma^2, ")/", gamma^2)))

## beta_0 RMSE
plot_results_score("beta_0.RMSE", 
                   expression(paste("RMSE(", beta[0], ")")))

## log_likelihood
plot_results_score("log_likelihood.mean", "Log_Likelihood")

## ARI
plot_results_score("mean.adjrandind", "ARI")

## K match
plot_results_score("K.match", "Percent Exact Match")

## K_true vs K_select
nbr_inferences_K <- function(df){
  len <- unique(floor(sqrt(nta)))
  res <- vector(length = len + 1)
  names(res) <- 0:len
  for (K_e in 0:len){
    res[K_e + 1] <- sum(df$K_select == K_e) / length(df$K_select)
  }
  names(res) <- 0:len
  return(res)
}

incidences_K_select <- ddply(results_summary,
                             .(K, ntaxa),
                             nbr_inferences_K)

incidences_K_select <- melt(incidences_K_select, id.vars = c("K", "ntaxa"), variable.name = "K_select", value.name = "frequence_observed")
incidences_K_select$K_select <- as.numeric(levels(incidences_K_select$K_select))[incidences_K_select$K_select]

incidences_K_select <- merge(results_summary, incidences_K_select)

p <- ggplot(incidences_K_select, aes(x = K, y = K_select, size = frequence_observed))
p <- p + facet_grid(. ~ ntaxa, labeller = my.labeller)
p <- p + geom_abline(intercept = 0, slope=1)
p <- p + geom_hline(aes(yintercept = floor(sqrt(ntaxa))))
p <- p + geom_smooth(method = "lm", se = FALSE, show_guide=FALSE)
p <- p + geom_point()
p <- p + scale_size(name = "Frequence Estimated")
#                           breaks = c("FALSE", "TRUE"),
#                           labels = c("Estimated", "Known"))
p <- p + theme_bw()
p <- p + theme(axis.text = element_text(size = 12),
               strip.text = element_text(size = 12)
               ##legend.position = c(0, 1),
               ##legend.justification = c(0, 1)
)
p

## Faire un box plot
p <- ggplot(results_summary, aes(x = as.factor(K), y = K_select))
p <- p + facet_grid(. ~ ntaxa, labeller = my.labeller)
p <- p + geom_boxplot()
p <- p + geom_abline(intercept = 0, slope=1)
p <- p + geom_hline(aes(yintercept = floor(sqrt(ntaxa))))
p <- p + geom_smooth(aes(group = 1), method = "lm", se = FALSE, show_guide=FALSE)
p <- p + scale_size(name = "Frequence Estimated")
#                           breaks = c("FALSE", "TRUE"),
#                           labels = c("Estimated", "Known"))
p <- p + labs(x = "True K",
              y = "Selected K")
p <- p + coord_cartesian(ylim = c(-0.5, 16.5))
p <- p + theme_bw()
p <- p + theme(axis.text = element_text(size = 12),
               strip.text = element_text(size = 12)
               ##legend.position = c(0, 1),
               ##legend.justification = c(0, 1)
)
p

## Sensibilité et spécificité
pushViewport(viewport(layout = grid.layout(1, 3, heights = unit(c(5), "null"))))
for (group in names(grp_id)) {
  data.grp <- subset(subset(subset(results_summary_K_select_true, K_type == "K_select"), ntaxa == 64), grp %in% c("base", group))
  data.grp$ntaxa <- as.factor(data.grp$ntaxa)
  data.grp[[unname(grp_id[group])]] <- as.factor(data.grp[[unname(grp_id[group])]])
  p <- ggplot(data.grp , aes_string(x = unname(grp_id[group]), y = "edge.recovery"))
  #   p <- p + scale_linetype(name = "ntaxa",
  #                           breaks = c("FALSE", "TRUE"),
  #                           labels = c("Estimated", "Known"))
  #   p <- p + geom_line(aes(colour = "Final")) + geom_line(aes(y = gamma.init.RMSE, colour = "Initial"))
  p <- p + geom_violin()
  p <- p + scale_colour_discrete(name = "Estimation")
  p <- p + labs(x = grp_var[group],
                y = "Sensitivity")
  p <- p + theme_bw()
  p <- p + theme(axis.text = element_text(size = 12),
                 strip.text = element_text(size = 12)
                 ##legend.position = c(0, 1),
                 ##legend.justification = c(0, 1)
  )
  print(p, vp=vplayout(1, which(group == names(grp_id))))
}
